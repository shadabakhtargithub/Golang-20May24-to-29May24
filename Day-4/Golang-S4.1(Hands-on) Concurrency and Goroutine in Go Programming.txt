*************************************************************************************************************************************************
					***** Golang-S12.1(Hands-on) Concurrency and Goroutine ***** 
*************************************************************************************************************************************************
// Example illustrating the concurrent execution of tasks using Goroutines:

package main

import (
	"fmt"
	"sync"
	"time"
)

func task1() {
	for i := 0; i < 5; i++ {
		fmt.Println("Task 1:", i)
		time.Sleep(time.Millisecond * 500)
	}
}

func task2() {
	for i := 0; i < 5; i++ {
		fmt.Println("Task 2:", i)
		time.Sleep(time.Millisecond * 400)
	}
}

func main() {
                   // A WaitGroup is used to wait for a collection of goroutines to finish executing
	var wg sync.WaitGroup

	/* Start Goroutines for task1 and task2
                       wg.Add(2) tells the WaitGroup that it should wait for two additional operations (or goroutines) to complete */

	wg.Add(2)
	go func() {
		defer wg.Done()
		task1()
	}()
	go func() {
		defer wg.Done()
		task2()
	}()

	// Wait for both Goroutines to finish
	wg.Wait()

	fmt.Println("All tasks completed.")
}

In this example, two tasks (task1 and task2) are executed concurrently using Goroutines. We use a sync.WaitGroup to ensure that the main program waits for both 
Goroutines to finish before printing "All tasks completed."

As you run this program, you'll observe that the output from both tasks is interleaved, indicating concurrent execution. Using Goroutines, you can efficiently perform 
concurrent operations, which is particularly useful for tasks like I/O operations, parallel processing, and handling multiple requests in web servers.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Concurrency - **Goroutines**

package main

import (
    "fmt"
    "time"
)

func say(s string) {
    for i := 0; i < 3; i++ {
        time.Sleep(100 * time.Millisecond)
        fmt.Println(s)
    }
}

func main() {
    go say("world")
    say("hello")
}
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Concurrency with wait group and net/http package

package main

import (
	"fmt"
	"net/http"
	"sync"
)

var wg sync.WaitGroup

func main() {
	websitelists := []string{
		"https://www.skillwisegroup.com/",
		"https://google.com/",
		"https://github.com/",
		"https://meta.com/",
		"https://shadabblogs.com/",
	}
	for _, web := range websitelists {
		go getStatusCode(web)
		wg.Add(1)
	}

	wg.Wait()
}

func getStatusCode(endpoint string) {

	defer wg.Done()

	res, err := http.Get(endpoint)

	if err != nil {
		fmt.Println("Oops in endpoint")

	} else {
		fmt.Printf("%d status code for %s\n", res.StatusCode, endpoint)
	}
}
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Mutex in Golang

package main

import (
	"fmt"
	"net/http"
	"sync"
)

var signals = []string{"test"}
var wg sync.WaitGroup
var mut sync.Mutex

func main() {
	websitelists := []string{
		"https://www.skillwisegroup.com/",
		"https://google.com/",
		"https://github.com/",
		"https://meta.com/",
	}
	for _, web := range websitelists {
		go getStatusCode(web)
		wg.Add(1)
	}

	wg.Wait()
	fmt.Println(signals)
}

func getStatusCode(endpoint string) {

	defer wg.Done()

	res, err := http.Get(endpoint)

	if err != nil {
		fmt.Println("Oops in endpoint")

	} else {
		mut.lock()
		signals = append(signals, endpoint)
		mut.unlock()
		fmt.Printf("%d status code for %s\n", res.StatusCode, endpoint)
	}
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
								----- END ----- 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------